<!DOCTYPE html>
<html>
<head>
  <title>Docker for JavaScript Developers</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="theme/css/default.css">
  <base target="_blank">
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0" class="blur-none">

<slides class="layout-widescreen">

  <slide class="title-slide segue nobackground">
    <aside class="note">
      <section>
        [start screenflow! record everything (except computer audio)]<br/>
        [Cmd+F to go fullscreen on viewer tab; not native thingy!]<br/>
        [turn off key repeat!]
      </section>
    </aside>
    <hgroup>
      <h1>Docker for JavaScript Developers</h1>
      <h3>
        Jörn Zaefferer<br>
        <a href="http://bassistance.de">bassistance.de</a> /
        <a href="https://twitter.com/bassistance">@bassistance</a><br>
        <a href="http://jzaefferer.github.io/slides-docker-for-js-devs/">jzaefferer.github.io/slides-docker-for-js-devs/</a>
      </h3>
    </hgroup>
  </slide>
  <slide class="title-slide segue nobackground">
    <aside class="note">
      <section>
        Welcome to CologneJS. My name is Jörn Zaefferer. I've been writing JavaScript professionally for 11 years now, both on open source projects like jQuery, jQuery UI or QUnit, and on many commercial projects, like SoundCloud and in the last two and a half years, for sloppy.io. That is where I also learned a lot about Docker, since we're offering Docker container hosting, and using containers internally a lot.
      </section>
    </aside>
    <hgroup>
      <h1>'bout me</h1>
      <h3>
        <ul>
          <li>11 years writing JavaScript</li>
          <li>jQuery, jQuery UI, QUnit</li>
          <li>Commercial products like SoundCloud</li>
          <li>Head of development sloppy.io</li>
        </ul>
      </h3>
    </hgroup>
  </slide>
  <slide class="title-slide segue nobackground">
    <aside class="note">
      <section>
        Hands up if you've worked with Docker!<br>
        [do an estimate] Alright.<br>
        Either way, I'm not going to teach you how to use Docker. I am going to show Docker solutions for JavaScript specific issues. They should be understandable even if you don't yet know Docker.
      </section>
    </aside>
    <hgroup>
      <h1>'bout you</h1>
      <h3>Have you worked with Docker?</h3>
    </hgroup>
  </slide>

  <slide class="segue big dark pattern-1">
    <aside class="note">
      <section>
        Before we get to the code examples, a bit of theory<br/>
        If you currently have a setup that works okay, why would you bother with Docker?<br/>
        Here's a few arguments that might work for you.<br/>
        node/npm on Windows can have path issues or incompatible binaries, using Docker avoids these<br/>
        Managing node/npm versions per project is annoying, Docker does that well<br/>
        Containers open up new options for deployments and operations! Once your app is in a container, it can run in many environments!
      </section>
    </aside>
    <hgroup>
      <h2>Why Docker?</h2>
      <h3>
        <ul>
          <li>Works on Windows, OSX and Linux</li>
          <li>Manage different version like node/npm</li>
          <li>Deploy to cloud, with less vendor lock-in</li>
        </ul>
      </h3>
    </hgroup>
  </slide>

  <slide class="segue big dark pattern-2">
    <aside class="note">
      <section>
        All the code is in two GitHub repositories!<br/>
        No need to copy code examples, they're all in there<br/>
        They're fully functional, can you try them later.<br/>
        The web app is based on create-react-app and renders a little bit of text, but also does a GET request to a backend server<br/>
        The other project is a nodejs app based on express, and provides a REST API on top of CouchDB
      </section>
    </aside>
    <hgroup>
      <h2>Let's look at code!</h2>
      <h3>
        All on GitHub:
        <ul>
          <li>github.com/jzaefferer/docker-for-js-devs web app based on create-react-app</li>
          <li>github.com/jzaefferer/docker-for-nodejs-devs rest backend, nodejs and express, with CouchDB</a></li>
        </ul>
      </h3>
    </hgroup>
  </slide>

  <!-- Docker locally -->
  <slide class="segue big dark pattern-3">
    <aside class="note">
      <section>
        To start, let's look how we can use Docker for local development<br/>
        For that I'll show you how to build Docker images that include file watchers, so that changes in the editor show up inside the app.<br/>
      </section>
    </aside>
    <hgroup>
      <h2>Docker locally</h2>
    </hgroup>
  </slide>
  <slide>
    <aside class="note">
      <section>
        6 instructions for conquering the world!<br/>
        FROM is our starting point, here a light weight build of node 8 based on alpine.<br/>
        WORKDIR tells Docker where to copy files. Can be pretty much any directory<br/>
        The first COPY only copies files we need to install dependencies with npm<br/>
        The RUN then does just that<br/>
        Afterwards another COPY copies all files, from the host, to the docker image. This way we can use Docker's cache for dependencies as long as package.json doesn't change.<br/>
        Finally CMD is the command to run, here starting a server with file watcher
      </section>
    </aside>
    <hgroup>
      <h2>Dockerfile</h2>
    </hgroup>
    <article>
      <textarea class="prettyprint" data-lang="Dockerfile">
        FROM node:8-alpine

        WORKDIR /usr/src/app

        `COPY package.json package-lock.json ./`
        RUN npm install --silent

        COPY . .

        CMD npm start
      </textarea>
    </article>
  </slide>
  <slide>
    <aside class="note">
      <section>
        It just said that the 'COPY dot dot' copies all files, but that's not quite true.<br/>
        It doesn't copy any files specified in the .dockerignore file, which looks like this<br/>
        This is pretty much the same as your .gitignore or .npmignore file<br/>
        None of these files are need inside the container, so not copying them makes for smaller images and faster builds.
      </section>
    </aside>
    <hgroup>
      <h2>.dockerignore</h2>
    </hgroup>
    <article>
      <textarea class="prettyprint" data-lang=".dockerignore">
        .editorconfig
        .git
        docker-compose.yml
        Dockerfile
        Dockerfile-prod
        node_modules
        README.md
        sloppy.yml
      </textarea>
    </article>
  </slide>
  <slide>
    <aside class="note">
      <section>
        To build and run this locally, we can use docker-compose<br/>
        In this very simple setup, we specify a single service, built on demand<br/>
        We specify the port to expose, to open the web app in the browser<br/>
        And we map files to the host, so that the webpack-dev-server can pick up changes
      </section>
    </aside>
    <hgroup>
      <h2>docker-compose.yml</h2>
    </hgroup>
    <article>
      <textarea class="prettyprint" data-lang="yml">
        version: "3"
        services:
          pet-reminder:
            build: .
            ports:
              - 3000:3000
            volumes:
              - .:/usr/src/app
      </textarea>
    </article>
  </slide>
  <slide>
    <aside class="note">
      <section>
        With these two files, we can now run docker-compose and get something like the following output (page 1)<br/>
        Here the Docker container is built
      </section>
    </aside>
    <hgroup>
      <h2>docker-compose up --build</h2>
    </hgroup>
    <article>
      <textarea class="prettyprint" data-lang="bash">
        $ docker-compose up --build
        Building pet-reminder
        Step 1/6 : FROM node:8-alpine
          ---> b7e15c83cdaf
        Step 2/6 : WORKDIR /usr/src/app
          ---> Using cache
          ---> f2d4399af6ff
        Step 3/6 : COPY package.json package-lock.json ./
          ---> 6382a5ccf1da
        Step 4/6 : RUN npm install --silent
          ---> Running in 50e9b8fcaef1
        added 1298 packages in 79.942s
          ---> 141da2d062f2
        Removing intermediate container 50e9b8fcaef1
        Step 5/6 : COPY . .
          ---> 61ea82055581
        Step 6/6 : CMD npm start
          ---> Running in 6e31c194301c
          ---> a3e21611b6cb
        Removing intermediate container 6e31c194301c
      </textarea>
    </article>
  </slide>
  <slide>
    <aside class="note">
      <section>
        (page 2) Here the built container is tagged and started
      </section>
    </aside>
    <hgroup>
      <h2>docker-compose up --build</h2>
    </hgroup>
    <article>
      <textarea class="prettyprint" data-lang="bash">
        Successfully tagged dockerforjsdevs_pet-reminder:latest
        Recreating dockerforjsdevs_pet-reminder_1 ... done
        Attaching to dockerforjsdevs_pet-reminder_1
        pet-reminder_1  |
        pet-reminder_1  | > pet-reminder@0.1.0 start /usr/src/app
        pet-reminder_1  | > react-scripts start
        pet-reminder_1  |
        pet-reminder_1  | Starting the development server...
        pet-reminder_1  |
        pet-reminder_1  | Compiled successfully!
        pet-reminder_1  |
        pet-reminder_1  | You can now view pet-reminder in the browser.
        pet-reminder_1  |
        pet-reminder_1  |   Local:            http://localhost:3000/
        pet-reminder_1  |   On Your Network:  http://172.18.0.2:3000/
        pet-reminder_1  |
        pet-reminder_1  | Note that the development build is not optimized.
        pet-reminder_1  | To create a production build, use npm run build.
        pet-reminder_1  |
      </textarea>
    </article>
  </slide>
  <slide>
    <aside class="note">
      <section>
        With that we can open the app in the browser, and it automatically reloads as we make changes (using create-react-app)<br/>
        Let's look at the equivalent files for the nodejs app
      </section>
    </aside>
    <hgroup>
      <h2>http://localhost:3000/</h2>
    </hgroup>
    <article>
      <iframe src="https://pet-reminder.sloppy.zone/"></iframe>
    </article>
  </slide>
  <!-- nodejs -->
  <slide>
    <aside class="note">
      <section>
        Dockerfile: Exactly the same!
      </section>
    </aside>
    <hgroup>
      <h2>Dockerfile, nodejs</h2>
    </hgroup>
    <article>
      <textarea class="prettyprint" data-lang="Dockerfile">
        FROM node:8-alpine

        WORKDIR /usr/src/app

        `COPY package.json package-lock.json ./`
        RUN npm install --silent

        COPY . .

        CMD npm start
      </textarea>
    </article>
  </slide>
  <slide>
    <aside class="note">
      <section>
        This launches both the nodejs app as well as a couchdb instance<br/>
        Here we see how docker, via docker-compose, helps us avoid installing binaries locally.
      </section>
    </aside>
    <hgroup>
      <h2>docker-compose.yml, nodejs</h2>
    </hgroup>
    <article>
      <textarea class="prettyprint" data-lang="yml">
        version: '3'
        services:
          app:
            build: .
            volumes:
              - .:/usr/src/app
            environment:
              - PORT=7777
              - COUCHDB_URL=http://admin:sikrit@`db`:5984
            ports:
              - 7777:7777
          `db:`
            image: couchdb:1.7.1
            ports:
              - 5984:5984
            environment:
              - COUCHDB_USER=admin
              - COUCHDB_PASSWORD=sikrit
      </textarea>
    </article>
  </slide>
  <slide>
    <aside class="note">
      <section>
        Opening this in the browser gives us a list of pets, as JSON, retrieved from the CouchDB instance running locally.<br/>
        There's more to developing locally, but Docker is less relevant there. So instead, let's look at...
      </section>
    </aside>
    <hgroup>
      <h2>http://localhost:7777/v1/pets</h2>
    </hgroup>
    <article>
      <iframe src="https://pet-reminder-api.sloppy.zone/v1/pets"></iframe>
    </article>
  </slide>

  <!-- building for production -->
  <slide class="segue big dark pattern-4">
    <aside class="note">
      <section>
        [read title]<br/>
        For that I'm going to start with the nodejs example
      </section>
    </aside>
    <hgroup>
      <h2>Building for production</h2>
    </hgroup>
  </slide>
  <slide>
    <aside class="note">
      <section>
        This is the Dockerfile we use for the local build
      </section>
    </aside>
    <hgroup>
      <h2>Dockerfile, nodejs</h2>
    </hgroup>
    <article>
      <textarea class="prettyprint" data-lang="Dockerfile">
        FROM node:8-alpine

        WORKDIR /usr/src/app

        COPY package.json package-lock.json ./
        `RUN npm install --silent`

        COPY . .

        `CMD npm start`
      </textarea>
    </article>
  </slide>
  <slide>
    <aside class="note">
      <section>
        This is the one for the production build<br/>
        As you can see, there's very little difference. We don't install any devDependencies (only production), and we run a different command to start the process without a file watcher
      </section>
    </aside>
    <hgroup>
      <h2>Dockerfile-prod, nodejs</h2>
    </hgroup>
    <article>
      <textarea class="prettyprint" data-lang="Dockerfile">
        FROM node:8-alpine

        WORKDIR /usr/src/app

        COPY package.json package-lock.json ./
        `RUN npm install --only=production --silent`

        COPY . .

        `CMD npm run prod`
      </textarea>
    </article>
  </slide>
  <slide>
    <aside class="note">
      <section>
        Turning this into a Docker image looks like this...<br/>
        Its almost a bit boring, so let's look at building with webpack and nginx
      </section>
    </aside>
    <hgroup>
      <h2>Building for nodejs</h2>
    </hgroup>
    <article>
      <textarea class="prettyprint" data-lang="bash">
        $ docker build -f Dockerfile-prod -t jzaefferer/pet-reminder-api .
        Sending build context to Docker daemon  252.9kB
        Step 1/6 : FROM node:8-alpine
         ---> 4db2697ce114
        Step 2/6 : WORKDIR /usr/src/app
         ---> 1ca5a8710e25
        Step 3/6 : COPY package.json package-lock.json ./
         ---> 463f204fbfd2
        Step 4/6 : RUN npm install --only=production --silent
         ---> Running in 3782c10fd2ac
        added 131 packages in 7.314s
         ---> eace0b44fefe
        Step 5/6 : COPY . .
         ---> 064d6d0bfc9e
        Step 6/6 : CMD npm run prod
         ---> Running in 2e9ef5a31a6e
         ---> daebec187dc0
        Successfully built daebec187dc0
        Successfully tagged jzaefferer/pet-reminder-api:latest
      </textarea>
    </article>
  </slide>
  <!-- webpack -->
  <slide>
    <aside class="note">
      <section>
        For the web app, we want to use nginx to serve static html files<br/>
        But since we first need to build those files, we need to steps<br/>
        Thanks for multistage Docker builds, we can put this into a single Dockerfile.<br/>
        This is the first half. Its very similar to the previous Dockerfile,
        except for the 'as builder' in the FROM command. And we copy less files, to make the best use of the Docker cache.
      </section>
    </aside>
    <hgroup>
      <h2>Dockerfile-prod, webpack/nginx</h2>
    </hgroup>
    <article>
      <textarea class="prettyprint" data-lang="Dockerfile">
        `FROM node:8-alpine as builder`

        WORKDIR /usr/src/app

        COPY package.json package-lock.json ./
        RUN npm install --only=production --silent

        COPY public public/
        COPY src src/

        RUN npm run build

        `## 2nd stage`

        `FROM nginx:1.13.6-alpine`

        [...]
      </textarea>
    </article>
  </slide>
  <slide>
    <aside class="note">
      <section>
        In the second stage, we start with a different base image, here nginx-alpine.<br/>
        We then copy the built files from the first stage, using the --form=builder argument<br/>
      </section>
    </aside>
    <hgroup>
      <h2>Dockerfile-prod, webpack/nginx</h2>
    </hgroup>
    <article>
      <textarea class="prettyprint" data-lang="Dockerfile">
        [...]

        ## 2nd stage

        `FROM nginx:1.13.6-alpine`

        COPY nginx.conf /etc/nginx/nginx.conf
        `COPY --from=builder` /usr/src/app/build /usr/share/nginx/html/
        `COPY --from=builder` /usr/src/app/build/index.html /usr/share/nginx/index-template.html

        COPY nginx-entrypoint.sh /

        ENTRYPOINT ["sh", "/nginx-entrypoint.sh"]

        CMD ["nginx"]
      </textarea>
    </article>
  </slide>
  <slide>
    <aside class="note">
      <section>
        When we build this, we output a very compact nginx image, weighing just 7 MBs, using a single docker-build command. No extra scripts needed.<br/>
        This is the relevant output from the first stage, creating the production files
      </section>
    </aside>
    <hgroup>
      <h2>Building for webpack/nginx, stage 1</h2>
    </hgroup>
    <article>
      <textarea class="prettyprint" data-lang="bash">
        $ docker build -f Dockerfile-prod -t jzaefferer/pet-reminder .
        Sending build context to Docker daemon   1.11MB
        Step 1/14 : FROM node:8-alpine as builder
         ---> 4db2697ce114
        [...]
        Step 7/14 : RUN npm run build
         ---> Running in b5c7bae85ab5

        > pet-reminder@0.1.0 build /usr/src/app
        > react-scripts build

        Creating an optimized production build...
        Compiled successfully.

          35.73 KB  build/static/js/main.e123ee39.js
          318 B     build/static/css/main.83efae16.css

         ---> ac3ee777c1b1
      </textarea>
    </article>
  </slide>
  <slide>
    <aside class="note">
      <section>
        Which are then copied to the right folders in the second stage, resulting in the nginx image with static html, js and css files.
      </section>
    </aside>
    <hgroup>
      <h2>Building for webpack/nginx, stage 2</h2>
    </hgroup>
    <article>
      <textarea class="prettyprint" data-lang="bash">
        Step 8/14 : FROM nginx:1.13.6-alpine
        1.13.6-alpine: Pulling from library/nginx
         ---> 5c6da346e3d6
        Step 9/14 : COPY nginx.conf /etc/nginx/nginx.conf
         ---> 2b9a65e251bd
        Step 10/14 : COPY --from=builder /usr/src/app/build /usr/share/nginx/html/
         ---> 555c8890ce24
        Step 11/14 : COPY --from=builder /[...]/index.html /usr/share/nginx/index-template.html
         ---> 02b45d2a4f74
        Step 12/14 : COPY nginx-entrypoint.sh /
         ---> e4927e1c0421
        Step 13/14 : ENTRYPOINT ["sh", "/nginx-entrypoint.sh"]
         ---> Running in 30ccf88c8d87
         ---> 709178c294ec
        Step 14/14 : CMD ["nginx"]
         ---> Running in b2ef0cfb1921
         ---> 55c59a57f14e
        Successfully built 55c59a57f14e
        Successfully tagged jzaefferer/pet-reminder:latest
      </textarea>
    </article>
  </slide>
  <slide class="full nobackground">
    <aside class="note">
      <section>
        Here's the tag after pushing the image to Docker Hub
      </section>
    </aside>
    <img src="images/docker-hub-web.png">
  </slide>
  <slide class="full nobackground">
    <aside class="note">
      <section>
        The nodejs image is a bit bigger, but 29 MB is also very compact
      </section>
    </aside>
    <img src="images/docker-hub-api.png">
  </slide>

  <!-- deploying -->
  <slide class="segue big dark pattern-5">
    <aside class="note">
      <section>
        When it comes to deploying containers, we have a loooot of options.
      </section>
    </aside>
    <hgroup>
      <h2>Deploying containers</h2>
    </hgroup>
  </slide>

  <slide>
    <aside class="note">
      <section>
        You could install Docker in a VM, hosted anywhere<br/>
        That's an option, but then you also need to manage everything yourself
      </section>
    </aside>
    <hgroup>
      <h2>Self-host Docker in VM, with any VM hoster</h2>
    </hgroup>
    <article>
      <ul>
        <li>AWS</li>
        <li>DigitalOcean</li>
        <li>Azure</li>
        <li>...any</li>
        <li>other</li>
        <li>VM</li>
        <li>hoster...</li>
      </ul>
    </article>
  </slide>
  <slide>
    <aside class="note">
      <section>
        You could use a platorm built on top of Docker<br/>
        Still need to manage the underlying resources and the platform on top
      </section>
    </aside>
    <hgroup>
      <h2>Self-host Docker-orchestration platform in VM</h2>
    </hgroup>
    <article>
      <ul>
        <li>Docker Swarm</li>
        <li>Kubernetes</li>
        <li>DC/OS</li>
        <li>Rancher</li>
        <li>Dokku</li>
      </ul>
    </article>
  </slide>
  <slide>
    <aside class="note">
      <section>
        You could let someone else host the platform built on top of Docker<br/>
        Less management on the OS level, but potentially still lots of work on the platform level
      </section>
    </aside>
    <hgroup>
      <h2>Use hosted Docker-orchestration platform</h2>
    </hgroup>
    <article>
      <ul>
        <li>usually Kubernetes...</li>
        <li>Google Container Engine</li>
        <li>Amazon Elastic Container Service</li>
        <li>Azure Container Service</li>
      </ul>
    </article>
  </slide>
  <slide>
    <aside class="note">
      <section>
        You could let someone else do most of the hosting for you, including load balancing, logging, monitoring, creating and updating SSL certificates...<br/>
        All you do is provide Docker images and a bit of configuration<br/>
        From what I can tell, the serious offers in this space are these three<br/>
        Since I know sloppy.io best, I'll show how to deploy there
      </section>
    </aside>
    <hgroup>
      <h2>Use hosted Docker</h2>
    </hgroup>
    <article>
      <ul>
        <li>hyper.sh</li>
        <li>zeit.co/now</li>
        <li>sloppy.io</li>
      </ul>
    </article>
  </slide>
  <!-- deploy to sloppy.io -->
  <slide>
    <aside class="note">
      <section>
        This is sloppy.io's yaml configuration. We configure the image to pull from Docker hub, set a domain for testing, along with the port, how much memory to give the container, and where to find the backend service.<br/>
        This can be used with the CLI; we could also use the web interface.
      </section>
    </aside>
    <hgroup>
      <h2>sloppy.yml, webpack/nginx</h2>
    </hgroup>
    <article>
      <textarea class="prettyprint" data-lang="yml">
        version: "v1"
        project: "pet-reminder"
        services:
          frontend:
            nginx:
              image: jzaefferer/pet-reminder
              domain: "pet-reminder.sloppy.zone"
              port: 80
              mem: 64
              instances: 1
              env:
                - PETS_API_URL: https://pet-reminder-api.sloppy.zone/
      </textarea>
    </article>
  </slide>
  <slide>
    <aside class="note">
      <section>
        Using the CLI, we tell it which config file to deploy.
      </section>
    </aside>
    <hgroup>
      <h2>sloppy change sloppy.yml</h2>
    </hgroup>
    <article>
      <textarea class="prettyprint" data-lang="bash">
        $ sloppy change sloppy.yml
        +----------+--------+--------+--------------+
        | SERVICE  | # APPS | STATUS | TOTAL MEMORY |
        +----------+--------+--------+--------------+
        | frontend |      1 |  1 / 1 |       64 MiB |
        +----------+--------+--------+--------------+
      </textarea>
    </article>
  </slide>
  <slide>
    <aside class="note">
      <section>
        In the web UI, we can then see the project getting deployed and running
      </section>
    </aside>
    <hgroup>
      <h2>web project on sloppy.io</h2>
    </hgroup>
    <article>
      <iframe src="https://admin.sloppy.io/project/pet-reminder"></iframe>
    </article>
  </slide>
  <!-- nodejs -->
  <slide>
    <aside class="note">
      <section>
        For the nodejs project, the process is the same. In addition to our own app, we also deploy CouchDB, just like we did with docker-compose locally before
      </section>
    </aside>
    <hgroup>
      <h2>sloppy.yml, nodejs</h2>
    </hgroup>
    <article>
      <textarea class="prettyprint" data-lang="yml">
          version: "v1"
          project: "pet-reminder-api"
          services:
            backend:
              api:
                image: jzaefferer/pet-reminder-api
                domain: "pet-reminder-api.sloppy.zone"
                port: 7777
                env:
                  - PORT: "7777"
                  - COUCHDB_URL: http://db.backend.pet-reminder-api:5984
                dependencies:
                  - "db"
              db:
                image: couchdb:1.7.1
                domain: "pet-reminder-api-db.sloppy.zone"
                port: 5984
                volumes:
                  - container_path: /usr/local/var/lib/couchdb
      </textarea>
    </article>
  </slide>
  <slide>
    <aside class="note">
      <section>
        When deploying this, we can see two apps getting deployed
      </section>
    </aside>
    <hgroup>
      <h2>sloppy change sloppy.yml, nodejs</h2>
    </hgroup>
    <article>
      <textarea class="prettyprint" data-lang="bash">
        $ sloppy change sloppy.yml
        +---------+--------+--------+--------------+
        | SERVICE | # APPS | STATUS | TOTAL MEMORY |
        +---------+--------+--------+--------------+
        | backend |      2 |  2 / 2 |      384 MiB |
        +---------+--------+--------+--------------+
      </textarea>
    </article>
  </slide>
  <slide>
    <aside class="note">
      <section>
        And we can find this project in the web UI as well. Here we could also check stats and logs and so on. [if they manage to load]<br/>
        Deployment to other services will of course be different, but the basic idea should be the same. Use existing images along with your own, and connect those to a public URL.
      </section>
    </aside>
    <hgroup>
      <h2>api project on sloppy.io</h2>
    </hgroup>
    <article>
      <iframe src="https://admin.sloppy.io/project/pet-reminder-api"></iframe>
    </article>
  </slide>

  <!-- Configuration -->
  <!-- later...? -->

  <!-- Shortcomings -->
  <slide class="segue big dark pattern-1">
    <aside class="note">
      <section>
        There's more in the two code repositories, including a nice solution for runtime configuration via environment variables of the nginx image. That's too much detail to cover here though.<br/>
        Missing in those repos is integration of running linters and other testing tools, like unit tests. Also updating lock files still requires running npm or yarn outside of Docker. I haven't seen good solutions for either issue.<br/>
        I'm very much interested in solving those problems and improving the solutions I presented - please share your ideas! I’ll integrate them in future versions of this talk (and credit you, if you want).
      </section>
    </aside>
    <hgroup>
      <h2>To Be Improved</h2>
      <h3>
        <ul>
          <li>Skipped: Runtime configuration for static HTML</li>
          <li>Unsolved: Linter und (unit) test setup</li>
          <li>Unsolved: Updating lock files inside container</li>
        </ul>
      </h3>
    </hgroup>
  </slide>
  <!-- Summary/RFC -->
  <slide class="segue big dark pattern-2" hidden>
    <aside class="note">
      <section>
        [fnaifawnifiwna]
      </section>
    </aside>
    <hgroup>
      <h2>Closing</h2>
      <h3>
        <ul>
          <li>Docker locally</li>
          <li>Building for production</li>
          <li>Deploying</li>
        </ul>
      </h3>
    </hgroup>
  </slide>

  <!-- closing -->
  <slide class="thank-you-slide">
    <aside class="note">
      <section>
        If you want to contact me later: You can find me on Twitter or reach me by email<br/>
        The slides are online already, along with the two GitHub repositories<br/>
        [time for Q/A?]<br/>
        Thanks for your attention!
      </section>
    </aside>
    <article>
      <ul>
        <li><span>twitter</span><a href="http://twitter.com/@bassistance">@bassistance</a></li>
        <li><span>email</span><a href="mailto:joern.zaefferer@gmail.com">joern.zaefferer@gmail.com</a></li>
        <li><span>slides</span><a href="http://jzaefferer.github.io/slides-docker-for-js-devs/">jzaefferer.github.io/slides-docker-for-js-devs/</a></li>
        <li><span>code 1</span><a href="https://github.com/jzaefferer/docker-for-js-devs">github.com/jzaefferer/docker-for-js-devs</a></li>
        <li><span>code 2</span><a href="https://github.com/jzaefferer/docker-for-nodejs-devs">github.com/jzaefferer/docker-for-nodejs-devs</a></li>
        <li><span>thanks</span> Katharina Schlüter, Martin Malinowski</li>
      </ul>
    </article>
  </slide>

  <slide class="backdrop"></slide>
</slides>
</body>
</html>
